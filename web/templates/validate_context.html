<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Validation du contexte - Poker Training</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container { max-width: 1100px; margin: 0 auto; }

        .header {
            background: white;
            padding: 20px 30px;
            border-radius: 10px 10px 0 0;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .header h1 { color: #333; font-size: 24px; margin-bottom: 10px; }

        .context-info {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }

        .context-info p { color: #666; margin: 5px 0; font-size: 14px; }
        .context-info strong { color: #333; }

        .warning-box {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 5px;
            padding: 12px 15px;
            margin: 15px 0;
        }

        .warning-box h3 {
            color: #856404;
            font-size: 14px;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .warning-box ul {
            margin: 0;
            padding-left: 20px;
            color: #856404;
            font-size: 13px;
        }

        .warning-box li { margin: 4px 0; }

        .form-container {
            background: white;
            padding: 30px;
            border-radius: 0 0 10px 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .form-section { margin-bottom: 30px; }
        .form-section h2 {
            color: #333; font-size: 18px; margin-bottom: 15px;
            padding-bottom: 10px; border-bottom: 2px solid #667eea;
        }
        .form-section.optional h2 { border-bottom-color: #95a5a6; }
        .form-section.subranges h2 { border-bottom-color: #e74c3c; }
        .form-section.context-details h2 { border-bottom-color: #3498db; }

        .form-group { margin-bottom: 20px; }
        .form-group label {
            display: block; color: #555; font-weight: 600;
            margin-bottom: 8px; font-size: 14px;
        }
        .form-group label .required { color: #e74c3c; margin-left: 3px; }
        .form-group label .optional { color: #95a5a6; margin-left: 3px; font-weight: normal; font-style: italic; }

        .form-group select, .form-group input {
            width: 100%; padding: 12px; border: 2px solid #e0e0e0;
            border-radius: 5px; font-size: 14px; transition: border-color 0.3s;
        }
        .form-group select:focus, .form-group input:focus {
            outline: none; border-color: #667eea;
        }

        .button-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
            gap: 10px; margin-top: 8px;
        }

        .btn-option {
            padding: 10px; border: 2px solid #e0e0e0; background: white;
            border-radius: 5px; cursor: pointer; transition: all 0.3s;
            font-size: 13px; font-weight: 500;
        }
        .btn-option:hover { border-color: #667eea; background: #f8f9ff; }
        .btn-option.selected { background: #667eea; color: white; border-color: #667eea; }
        .btn-option:disabled { opacity: 0.5; cursor: not-allowed; }

        .btn-option.disabled-pos {
            opacity: 0.3;
            cursor: not-allowed;
            background: #f5f5f5;
        }

        .btn-option.disabled-pos:hover {
            border-color: #e0e0e0;
            background: #f5f5f5;
        }

        .dynamic-section {
            display: none;
            background: #f0f7ff;
            padding: 15px;
            border-radius: 5px;
            border-left: 4px solid #3498db;
            margin-top: 15px;
        }

        .dynamic-section.visible {
            display: block;
        }

        .dynamic-section h3 {
            color: #2c3e50;
            font-size: 14px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .position-tag-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            min-height: 40px;
            padding: 8px;
            background: white;
            border-radius: 5px;
            border: 2px dashed #ddd;
        }

        .position-tag {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            background: #667eea;
            color: white;
            border-radius: 999px;
            font-size: 13px;
            font-weight: 600;
        }

        .position-tag button {
            background: none;
            border: none;
            color: white;
            cursor: pointer;
            font-size: 16px;
            padding: 0;
            margin-left: 4px;
        }

        .or-separator {
            position: relative;
            text-align: center;
            margin: 20px 0;
            padding-top: 20px;
            border-top: 2px dashed #ddd;
        }

        .or-separator span {
            position: absolute;
            top: -10px;
            left: 50%;
            transform: translateX(-50%);
            background: #f0f7ff;
            padding: 0 10px;
            color: #95a5a6;
            font-weight: 600;
            font-size: 12px;
        }

        .count-input {
            width: 120px !important;
        }

        .actions {
            display: flex; gap: 15px; margin-top: 30px;
            padding-top: 20px; border-top: 1px solid #e0e0e0;
        }
        .btn { flex: 1; padding: 15px 30px; border: none; border-radius: 5px;
              font-size: 16px; font-weight: 600; cursor: pointer; transition: all 0.3s; }
        .btn-primary { background: #667eea; color: white; }
        .btn-primary:hover { background: #5568d3; transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3); }
        .btn-secondary { background: #95a5a6; color: white; }
        .btn-secondary:hover { background: #7f8c8d; }
        .btn-danger { background: #e74c3c; color: white; }
        .btn-danger:hover { background: #c0392b; }

        .message { padding: 15px 20px; border-radius: 5px; margin-bottom: 20px; font-weight: 500; }
        .message.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .message.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }

        .subranges-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            background: white;
            border-radius: 5px;
            overflow: hidden;
        }

        .subranges-table thead {
            background: #f8f9fa;
        }

        .subranges-table th {
            padding: 12px;
            text-align: left;
            font-weight: 600;
            color: #333;
            font-size: 13px;
            border-bottom: 2px solid #e0e0e0;
        }

        .subranges-table td {
            padding: 12px;
            border-bottom: 1px solid #e0e0e0;
            font-size: 13px;
        }

        .subranges-table tbody tr:hover {
            background: #f8f9fa;
        }

        .range-color-cell {
            width: 40px;
        }

        .range-color-indicator {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid #e0e0e0;
        }

        .range-name-cell {
            font-weight: 600;
            color: #333;
        }

        .range-hands-cell {
            color: #666;
            text-align: center;
            width: 100px;
        }

        .range-label-cell {
            width: 200px;
        }

        .quiz-action-cell {
            width: 220px;
            padding-left: 15px !important;
        }

        .quiz-action-sequence {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }

        .quiz-action-group {
            display: flex;
            align-items: center;
            gap: 0;
            background: rgba(0,0,0,0.05);
            padding: 2px;
            border-radius: 6px;
        }

        .quiz-action-group .quiz-action-badge {
            border-radius: 4px;
        }

        .quiz-action-group .quiz-action-slash {
            margin: 0 4px;
        }

        .quiz-action-badge {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 4px;
            font-weight: 700;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            white-space: nowrap;
        }

        .quiz-action-raise {
            background: linear-gradient(135deg, #ffa726 0%, #ff9800 100%);
            color: white;
        }

        .quiz-action-call {
            background: linear-gradient(135deg, #66bb6a 0%, #4caf50 100%);
            color: white;
        }

        .quiz-action-fold {
            background: linear-gradient(135deg, #ef5350 0%, #e53935 100%);
            color: white;
        }

        .quiz-action-check {
            background: linear-gradient(135deg, #42a5f5 0%, #1e88e5 100%);
            color: white;
        }

        .quiz-action-none {
            background: #e0e0e0;
            color: #666;
            font-style: italic;
        }

        .quiz-action-arrow {
            color: #999;
            font-weight: bold;
            font-size: 14px;
        }

        .quiz-action-slash {
            color: #666;
            font-weight: bold;
            font-size: 14px;
            margin: 0 4px;
        }

        .range-label-select {
            width: 100%;
            padding: 8px;
            border: 2px solid #e0e0e0;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            transition: border-color 0.3s;
        }

        .range-label-select:focus {
            outline: none;
            border-color: #667eea;
        }

        .range-label-select.modified {
            border-color: #e74c3c;
            background: #fff5f5;
        }

        .badges, .chips { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px; }
        .badge, .chip {
            font-size: 12px; font-weight: 600; padding: 6px 10px; border-radius: 999px;
            background: #eef2ff; color: #334155; border: 1px solid #e2e8f0;
        }
        .slug-row { display: flex; align-items: center; gap: 8px; }
        .copy-btn {
            padding: 8px 14px;
            font-size: 13px;
            border: 1px solid #667eea;
            border-radius: 6px;
            background: white;
            color: #667eea;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.2s;
        }
        .copy-btn:hover {
            background: #667eea;
            color: white;
        }
        .copy-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        .small-dim { font-size: 12px; color: #666; }

        .help-text {
            font-size: 12px;
            color: #666;
            margin-top: 8px;
            font-style: italic;
        }

        .modified-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #e74c3c;
            margin-left: 8px;
        }

        .generic-info {
            background: #e8f5e9;
            border-left: 4px solid #4caf50;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
            color: #2e7d32;
        }

        .position-warning {
            background: #ffebee;
            border-left: 4px solid #f44336;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
            color: #c62828;
            font-weight: 600;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔧 Validation du contexte</h1>

            <div class="context-info">
                <p><strong>Fichier :</strong> <span id="filename">-</span></p>
                <p><strong>Nom original :</strong> <span id="original-name">-</span></p>
                <p><strong>Ranges :</strong> <span id="range-count">0</span></p>

                <p><strong>Titre :</strong> <span id="human-title">—</span></p>
                <p class="slug-row">
                    <strong>Slug :</strong> <code id="slug">—</code>
                    <button type="button" class="copy-btn" id="rename-btn" onclick="renameFile()">
                        Renommer le fichier
                    </button>
                </p>
                <div>
                    <strong>Résumé sous-ranges :</strong>
                    <div class="chips" id="subranges-summary">
                        <span class="small-dim">Aucun sous-range détecté</span>
                    </div>
                </div>
            </div>

            <div id="warnings-container"></div>
        </div>

        <div class="form-container">
            <div id="message-container"></div>

            <form id="validation-form">
                <!-- Métadonnées obligatoires -->
                <div class="form-section">
                    <h2>📋 Métadonnées obligatoires</h2>

                    <div class="form-group">
                        <label>Format de table <span class="required">*</span></label>
                        <div class="button-grid" id="table-format-buttons">
                            <button type="button" class="btn-option" data-value="6max">6max</button>
                            <button type="button" class="btn-option" data-value="9max">9max</button>
                            <button type="button" class="btn-option" data-value="5max">5max</button>
                            <button type="button" class="btn-option" data-value="HU">HU</button>
                        </div>
                        <input type="hidden" id="table-format" name="table_format" required>
                    </div>

                    <div class="form-group">
                        <label>Position héros <span class="required">*</span></label>
                        <div class="button-grid" id="hero-position-buttons">
                            <!-- Dynamiquement rempli selon le format -->
                        </div>
                        <input type="hidden" id="hero-position" name="hero_position" required>
                    </div>

                    <div class="form-group">
                        <label>Action principale <span class="required">*</span></label>
                        <p class="help-text">
                            Sélectionnez le type de situation de jeu principale
                        </p>
                        <div class="button-grid">
                            <button type="button" class="btn-option action-btn" data-value="open">🎯 Open</button>
                            <button type="button" class="btn-option action-btn" data-value="defense">🛡️ Defense</button>
                            <button type="button" class="btn-option action-btn" data-value="squeeze">🤜 Squeeze</button>
                            <button type="button" class="btn-option action-btn" data-value="vs_limpers">🌊 Vs Limpers</button>
                        </div>
                        <input type="hidden" id="primary-action" name="primary_action" required>
                    </div>
                </div>

                <!-- Section contexte détaillé (dynamique selon primary_action) -->
                <div class="form-section context-details">
                    <h2>🎲 Détails du contexte</h2>

                    <!-- Defense : opener -->
                    <div id="defense-details" class="dynamic-section">
                        <h3>🛡️ Defense (heads-up)</h3>
                        <p class="help-text">Vous défendez face à une ouverture unique</p>

                        <div id="defense-warning" class="position-warning">
                            ⚠️ Position invalide pour defense
                        </div>

                        <div class="form-group">
                            <label>Position de l'ouvreur <span class="optional">(optionnel)</span></label>
                            <p class="help-text">Laissez vide pour une range defense générique</p>
                            <div class="button-grid" id="opener-buttons">
                                <!-- Rempli dynamiquement -->
                            </div>
                            <input type="hidden" id="opener" name="opener">
                        </div>
                        <div class="generic-info">
                            💡 Une range générique (sans position) sera utilisable contre n'importe quel ouvreur
                        </div>
                    </div>

                    <!-- Squeeze : opener + callers -->
                    <div id="squeeze-details" class="dynamic-section">
                        <h3>🤜 Squeeze (multiway)</h3>
                        <p class="help-text">Vous squeezez face à une ouverture + call(s)</p>

                        <div id="squeeze-warning" class="position-warning">
                            ⚠️ Position invalide pour squeeze
                        </div>

                        <div class="form-group">
                            <label>Position de l'ouvreur <span class="optional">(optionnel)</span></label>
                            <p class="help-text">Laissez vide pour une range squeeze générique</p>
                            <div class="button-grid" id="squeeze-opener-buttons">
                                <!-- Rempli dynamiquement -->
                            </div>
                            <input type="hidden" id="squeeze-opener" name="squeeze_opener">
                        </div>

                        <div class="form-group">
                            <label>Méthode 1 : Positions spécifiques des callers <span class="optional">(optionnel)</span></label>
                            <p class="help-text">Sélectionnez les positions qui ont callé l'ouverture</p>
                            <div class="position-tag-container" id="callers-container">
                                <span class="small-dim">Aucun caller sélectionné</span>
                            </div>
                            <div class="button-grid" id="callers-buttons" style="margin-top: 10px;">
                                <!-- Rempli dynamiquement -->
                            </div>
                            <input type="hidden" id="callers" name="callers">
                        </div>

                        <div class="or-separator">
                            <span>OU</span>
                        </div>

                        <div class="form-group">
                            <label>Méthode 2 : Nombre de callers <span class="optional">(optionnel)</span></label>
                            <p class="help-text">Indiquez juste le nombre si les positions exactes n'importent pas</p>
                            <input type="text" id="callers-count" name="callers_count"
                                   placeholder="Ex: 1, 2, 3+"
                                   class="count-input">
                        </div>

                        <div class="generic-info">
                            💡 Une range squeeze générique pourra être utilisée dans toutes les situations multiway
                        </div>
                    </div>

                    <!-- Vs Limpers : limpers -->
                    <div id="limpers-details" class="dynamic-section">
                        <h3>🌊 Vs Limpers (multiway)</h3>
                        <p class="help-text">Vous agissez face à un ou plusieurs limps</p>

                        <div id="limpers-warning" class="position-warning">
                            ⚠️ Position invalide pour vs_limpers
                        </div>

                        <div class="form-group">
                            <label>Méthode 1 : Positions spécifiques des limpers <span class="optional">(optionnel)</span></label>
                            <p class="help-text">Sélectionnez les positions qui ont limpé</p>
                            <div class="position-tag-container" id="limpers-container">
                                <span class="small-dim">Aucun limpeur sélectionné</span>
                            </div>
                            <div class="button-grid" id="limpers-buttons" style="margin-top: 10px;">
                                <!-- Rempli dynamiquement -->
                            </div>
                            <input type="hidden" id="limpers" name="limpers">
                        </div>

                        <div class="or-separator">
                            <span>OU</span>
                        </div>

                        <div class="form-group">
                            <label>Méthode 2 : Nombre de limpers <span class="optional">(optionnel)</span></label>
                            <p class="help-text">Indiquez juste le nombre si les positions exactes n'importent pas</p>
                            <input type="text" id="limpers-count" name="limpers_count"
                                   placeholder="Ex: 1, 2, 3+"
                                   class="count-input">
                        </div>

                        <div class="generic-info">
                            💡 Une range vs_limpers générique pourra être utilisée contre n'importe quel nombre de limpers
                        </div>
                    </div>
                </div>

                <!-- Métadonnées optionnelles -->
                <div class="form-section optional">
                    <h2>⚙️ Métadonnées optionnelles</h2>

                    <div class="form-group">
                        <label>Profondeur de stack</label>
                        <select id="stack-depth" name="stack_depth">
                            <option value="100bb" selected>100bb (Standard)</option>
                            <option value="20bb">20bb (Short)</option>
                            <option value="50bb">50bb (Medium)</option>
                            <option value="200bb">200bb+ (Deep)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Type de jeu</label>
                        <select id="game-type" name="game_type">
                            <option value="Cash Game" selected>Cash Game</option>
                            <option value="Tournament">Tournament</option>
                            <option value="Sit & Go">Sit & Go</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Variante</label>
                        <select id="variant" name="variant">
                            <option value="NLHE" selected>NLHE (No Limit Hold'em)</option>
                            <option value="PLO">PLO (Pot Limit Omaha)</option>
                        </select>
                    </div>

                    <div class="form-group">
                        <label>Sizing</label>
                        <input type="text" id="sizing" name="sizing" placeholder="ex: 2.5x, 3bb, pot...">
                    </div>

                    <div class="form-group">
                        <label>Stakes</label>
                        <input type="text" id="stakes" name="stakes" placeholder="ex: NL10, NL25, NL50...">
                    </div>
                </div>

                <!-- Section validation sous-ranges -->
                <div class="form-section subranges">
                    <h2>🎯 Classification des sous-ranges <span id="modified-count"></span></h2>
                    <p class="help-text">
                        Vérifiez et corrigez si nécessaire les labels de chaque sous-range.
                        Les modifications sont indiquées en rouge.
                    </p>

                    <table class="subranges-table" id="subranges-table">
                        <thead>
                            <tr>
                                <th></th>
                                <th>Nom du range</th>
                                <th>Mains</th>
                                <th>Séquence d'actions quiz</th>
                                <th>Classification</th>
                            </tr>
                        </thead>
                        <tbody id="subranges-tbody">
                            <!-- Rempli dynamiquement -->
                        </tbody>
                    </table>
                </div>

                <!-- Checkbox pour mise à jour JSON -->
                <div class="form-group" style="margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" id="update-json" name="update_json" style="width: auto; margin-right: 10px;">
                        <span>✓ Mettre à jour le fichier JSON source avec ces métadonnées</span>
                    </label>
                    <p style="font-size: 12px; color: #666; margin-top: 5px; margin-left: 30px;">
                        Les métadonnées validées seront sauvegardées dans le fichier JSON d'origine.
                        Cela permettra une détection automatique à 100% lors du prochain import.
                    </p>
                </div>

                <div class="actions">
                    <button type="button" class="btn btn-secondary" onclick="window.location.href='/'">
                        ← Annuler
                    </button>
                    <button type="button" class="btn btn-danger" id="btn-ignore">
                        🗑️ Marquer non exploitable
                    </button>
                    <button type="submit" class="btn btn-primary">
                        ✓ Valider et sauvegarder
                    </button>
                </div>
            </form>
        </div>
    </div>

    <script>
        const POSITIONS_BY_FORMAT = {
            '5max': ['UTG', 'CO', 'BTN', 'SB', 'BB'],
            '6max': ['UTG', 'MP', 'CO', 'BTN', 'SB', 'BB'],
            '9max': ['UTG', 'UTG+1', 'MP', 'MP+1', 'LJ', 'HJ', 'CO', 'BTN', 'SB', 'BB'],
            'HU': ['BTN', 'BB']
        };

        let contextId = null;
        let contextData = null;
        let modifiedLabels = {};
        let originalLabels = {};
        let selectedCallers = [];
        let selectedLimpers = [];
        let currentTableFormat = '6max';

        // 🎮 Fonction qui génère la séquence d'actions de quiz
        function getQuizActionSequence(labelCanon, primaryAction, rangeKey) {
            if (!labelCanon || labelCanon === 'UNKNOWN' || labelCanon === 'None') {
                return [{ action: 'none', text: '—' }];
            }

            // Range principale (key = '1') : généralement pas de quiz direct si sous-ranges existent
            if (rangeKey === '1') {
                return [{ action: 'none', text: '—' }];
            }

            // Logique selon le contexte
            switch (primaryAction) {
                case 'open':
                    // Sous-ranges face à un 3bet (on a déjà open avant)
                    switch (labelCanon) {
                        case 'CALL':
                            // On open, puis face au 3bet : call
                            return [
                                { action: 'raise', text: 'RAISE' },
                                { arrow: true },
                                { action: 'call', text: 'CALL' }
                            ];
                        case 'R4_VALUE':
                            // On open, puis face au 3bet : 4bet, puis face au 5bet : RAISE/CALL
                            return [
                                { action: 'raise', text: 'RAISE' },
                                { arrow: true },
                                { action: 'raise', text: 'RAISE' },
                                { arrow: true },
                                { action: 'raise', text: 'RAISE', grouped: true },
                                { slash: true },
                                { action: 'call', text: 'CALL', grouped: true }
                            ];
                        case 'R4_BLUFF':
                            // On open, puis 4bet, puis fold au 5bet
                            return [
                                { action: 'raise', text: 'RAISE' },
                                { arrow: true },
                                { action: 'raise', text: 'RAISE' },
                                { arrow: true },
                                { action: 'fold', text: 'FOLD' }
                            ];
                        case 'FOLD':
                            // On open, puis fold au 3bet
                            return [
                                { action: 'raise', text: 'RAISE' },
                                { arrow: true },
                                { action: 'fold', text: 'FOLD' }
                            ];
                        default:
                            return [{ action: 'none', text: '—' }];
                    }

                case 'defense':
                    // Sous-ranges en défense (face à une ouverture)
                    switch (labelCanon) {
                        case 'CALL':
                            // Simple call de l'ouverture
                            return [{ action: 'call', text: 'CALL' }];
                        case 'R3_VALUE':
                        case 'R4_VALUE':
                            // On 3bet, puis face au 4bet : RAISE/CALL
                            return [
                                { action: 'raise', text: 'RAISE' },
                                { arrow: true },
                                { action: 'raise', text: 'RAISE', grouped: true },
                                { slash: true },
                                { action: 'call', text: 'CALL', grouped: true }
                            ];
                        case 'R3_BLUFF':
                        case 'R4_BLUFF':
                            // On 3bet, puis fold au 4bet
                            return [
                                { action: 'raise', text: 'RAISE' },
                                { arrow: true },
                                { action: 'fold', text: 'FOLD' }
                            ];
                        case 'FOLD':
                            return [{ action: 'fold', text: 'FOLD' }];
                        default:
                            return [{ action: 'none', text: '—' }];
                    }

                case 'squeeze':
                    // Squeeze : face à open + call(s)
                    switch (labelCanon) {
                        case 'CALL':
                            // Simple call du 3bet
                            return [{ action: 'call', text: 'CALL' }];
                        case 'R4_VALUE':
                            // On squeeze (3bet), puis face au 4bet : RAISE/CALL
                            return [
                                { action: 'raise', text: 'RAISE' },
                                { arrow: true },
                                { action: 'raise', text: 'RAISE', grouped: true },
                                { slash: true },
                                { action: 'call', text: 'CALL', grouped: true }
                            ];
                        case 'R4_BLUFF':
                            // On squeeze, puis fold au 4bet
                            return [
                                { action: 'raise', text: 'RAISE' },
                                { arrow: true },
                                { action: 'fold', text: 'FOLD' }
                            ];
                        case 'FOLD':
                            return [{ action: 'fold', text: 'FOLD' }];
                        default:
                            return [{ action: 'none', text: '—' }];
                    }

                case 'vs_limpers':
                    // Face à limpers : iso raise
                    switch (labelCanon) {
                        case 'OPEN':
                        case 'RAISE':
                        case 'ISO_RAISE':
                        case 'ISO_VALUE':
                        case 'ISO_BLUFF':
                            return [{ action: 'raise', text: 'RAISE' }];
                        case 'CALL':
                            return [{ action: 'call', text: 'CALL' }];
                        case 'FOLD':
                            return [{ action: 'fold', text: 'FOLD' }];
                        default:
                            return [{ action: 'none', text: '—' }];
                    }

                default:
                    // Fallback pour primary_action non reconnu
                    return [{ action: 'none', text: '—' }];
            }
        }

        // 🆕 VALIDATION DES POSITIONS PAR CONTEXTE (avec masquage dynamique)

        function validateDefensePositions() {
            const heroPosition = document.getElementById('hero-position').value;
            const primaryAction = document.getElementById('primary-action').value;
            const warningEl = document.getElementById('defense-warning');

            if (primaryAction !== 'defense' || !heroPosition) {
                if (warningEl) warningEl.style.display = 'none';
                return true;
            }

            const positions = POSITIONS_BY_FORMAT[currentTableFormat];
            const heroIdx = positions.indexOf(heroPosition);

            // Héros doit être au moins à l'index 1 pour defense
            if (heroIdx < 1) {
                if (warningEl) {
                    warningEl.style.display = 'block';
                    warningEl.textContent =
                        `⚠️ Pour defense, le héros doit être au moins en position ${positions[1]} (besoin d'au moins une position avant pour l'opener)`;
                }
                return false;
            }

            // ✅ Position valide → masquer le warning
            if (warningEl) warningEl.style.display = 'none';
            updateDefensePositionConstraints(positions, heroIdx);
            return true;
        }

        function validateSqueezePositions() {
            const heroPosition = document.getElementById('hero-position').value;
            const primaryAction = document.getElementById('primary-action').value;
            const warningEl = document.getElementById('squeeze-warning');

            if (primaryAction !== 'squeeze' || !heroPosition) {
                if (warningEl) warningEl.style.display = 'none';
                return true;
            }

            const positions = POSITIONS_BY_FORMAT[currentTableFormat];
            const heroIdx = positions.indexOf(heroPosition);

            // Héros doit être au moins à l'index 2 pour squeeze
            if (heroIdx < 2) {
                if (warningEl) {
                    warningEl.style.display = 'block';
                    warningEl.textContent =
                        `⚠️ Pour squeeze, le héros doit être au moins en position ${positions[2]} (besoin de place pour opener + caller(s))`;
                }
                return false;
            }

            // ✅ Position valide → masquer le warning
            if (warningEl) warningEl.style.display = 'none';
            updateSqueezePositionConstraints(positions, heroIdx);
            return true;
        }

        function validateLimpersPositions() {
            const heroPosition = document.getElementById('hero-position').value;
            const primaryAction = document.getElementById('primary-action').value;
            const warningEl = document.getElementById('limpers-warning');

            if (primaryAction !== 'vs_limpers' || !heroPosition) {
                if (warningEl) warningEl.style.display = 'none';
                return true;
            }

            const positions = POSITIONS_BY_FORMAT[currentTableFormat];
            const heroIdx = positions.indexOf(heroPosition);

            // Héros doit être au moins à l'index 1 pour vs_limpers
            if (heroIdx < 1) {
                if (warningEl) {
                    warningEl.style.display = 'block';
                    warningEl.textContent =
                        `⚠️ Pour vs_limpers, le héros doit être au moins en position ${positions[1]} (besoin d'au moins une position avant pour les limpers)`;
                }
                return false;
            }

            // ✅ Position valide → masquer le warning
            if (warningEl) warningEl.style.display = 'none';
            updateLimpersPositionConstraints(positions, heroIdx);
            return true;
        }

        function updateDefensePositionConstraints(positions, heroIdx) {
            const openerButtons = document.getElementById('opener-buttons');
            if (!openerButtons) return;

            openerButtons.querySelectorAll('.btn-option').forEach(btn => {
                const pos = btn.dataset.value;
                const posIdx = positions.indexOf(pos);

                // Désactiver si après ou égal au héros
                if (posIdx >= heroIdx) {
                    btn.disabled = true;
                    btn.classList.add('disabled-pos');
                    btn.title = 'Doit être avant le héros';
                } else {
                    btn.disabled = false;
                    btn.classList.remove('disabled-pos');
                    btn.title = '';
                }
            });
        }

        function updateSqueezePositionConstraints(positions, heroIdx) {
            // OPENER : au moins 2 positions avant le héros
            const minOpenerGap = 2;
            const maxOpenerIdx = heroIdx - minOpenerGap;

            const openerButtons = document.getElementById('squeeze-opener-buttons');
            if (openerButtons) {
                openerButtons.querySelectorAll('.btn-option').forEach(btn => {
                    const pos = btn.dataset.value;
                    const posIdx = positions.indexOf(pos);

                    // Désactiver si trop proche du héros
                    if (posIdx > maxOpenerIdx || posIdx >= heroIdx) {
                        btn.disabled = true;
                        btn.classList.add('disabled-pos');
                        btn.title = `Position trop proche du héros (besoin de ${minOpenerGap} positions d'écart minimum)`;
                    } else {
                        btn.disabled = false;
                        btn.classList.remove('disabled-pos');
                        btn.title = '';
                    }
                });
            }

            // CALLERS : entre opener et héros
            updateCallersConstraints(positions, heroIdx);
        }

        function updateCallersConstraints(positions, heroIdx) {
            const opener = document.getElementById('squeeze-opener').value;
            const callersButtons = document.getElementById('callers-buttons');

            if (!callersButtons) return;

            callersButtons.querySelectorAll('.btn-option').forEach(btn => {
                const pos = btn.dataset.value;
                const posIdx = positions.indexOf(pos);

                // Toujours invalides : après le héros
                if (posIdx >= heroIdx) {
                    btn.disabled = true;
                    btn.classList.add('disabled-pos');
                    btn.title = 'Doit être avant le héros';
                    return;
                }

                // Si opener sélectionné, callers doivent être après opener
                if (opener) {
                    const openerIdx = positions.indexOf(opener);
                    if (posIdx <= openerIdx) {
                        btn.disabled = true;
                        btn.classList.add('disabled-pos');
                        btn.title = 'Doit être après l\'opener';
                    } else {
                        btn.disabled = false;
                        btn.classList.remove('disabled-pos');
                        btn.title = '';
                    }
                } else {
                    // Pas d'opener : désactiver tant qu'opener pas sélectionné
                    btn.disabled = true;
                    btn.classList.add('disabled-pos');
                    btn.title = 'Sélectionnez d\'abord un opener';
                }
            });
        }

        function updateLimpersPositionConstraints(positions, heroIdx) {
            const limpersButtons = document.getElementById('limpers-buttons');
            if (!limpersButtons) return;

            limpersButtons.querySelectorAll('.btn-option').forEach(btn => {
                const pos = btn.dataset.value;
                const posIdx = positions.indexOf(pos);

                // Désactiver si après ou égal au héros
                if (posIdx >= heroIdx) {
                    btn.disabled = true;
                    btn.classList.add('disabled-pos');
                    btn.title = 'Doit être avant le héros';
                } else {
                    btn.disabled = false;
                    btn.classList.remove('disabled-pos');
                    btn.title = '';
                }
            });
        }

        // 🆕 FONCTION DE GÉNÉRATION DU SLUG EN TEMPS RÉEL
        function generateSlugLive() {
            const tableFormat = document.getElementById('table-format').value || '6max';
            const heroPosition = document.getElementById('hero-position').value || 'UTG';
            const primaryAction = document.getElementById('primary-action').value || 'open';
            const stackDepth = document.getElementById('stack-depth').value || '100bb';

            let ctxKey = '';

            // OPEN
            if (primaryAction === 'open') {
                ctxKey = 'open';
            }
            // DEFENSE
            else if (primaryAction === 'defense') {
                const opener = document.getElementById('opener').value;
                if (opener) {
                    ctxKey = `defense-vs-${opener.toLowerCase()}`;
                } else {
                    ctxKey = 'defense';
                }
            }
            // SQUEEZE
            else if (primaryAction === 'squeeze') {
                const opener = document.getElementById('squeeze-opener').value;
                const positions = [opener, ...selectedCallers].filter(p => p);

                if (positions.length > 0) {
                    ctxKey = `squeeze-${positions.map(p => p.toLowerCase()).join('-')}`;
                } else {
                    ctxKey = 'squeeze';
                }
            }
            // VS_LIMPERS
            else if (primaryAction === 'vs_limpers') {
                const limpersCount = document.getElementById('limpers-count').value;

                if (limpersCount) {
                    ctxKey = `vs-${limpersCount}limpers`;
                } else if (selectedLimpers.length > 0) {
                    ctxKey = `vs-limpers-${selectedLimpers.map(l => l.toLowerCase()).join('-')}`;
                } else {
                    ctxKey = 'vs-limpers';
                }
            }
            else {
                ctxKey = primaryAction.replace(/\s+/g, '-');
            }

            // Construire le slug
            const slug = `nlhe-${tableFormat.replace(/\s+/g, '').toLowerCase()}-${heroPosition.toLowerCase()}-${ctxKey}-${stackDepth.toLowerCase()}`;

            // Nettoyer le slug (enlever caractères spéciaux)
            const cleanSlug = slug.replace(/[^a-z0-9\-\.]/g, '');

            // Mettre à jour l'affichage
            const slugElement = document.getElementById('slug');
            if (slugElement) {
                slugElement.textContent = cleanSlug;
            }

            // Mettre à jour aussi le titre humain
            updateHumanTitle();
        }

        // 🆕 FONCTION DE GÉNÉRATION DU TITRE HUMAIN EN TEMPS RÉEL
        function updateHumanTitle() {
            const tableFormat = document.getElementById('table-format').value || '6max';
            const heroPosition = document.getElementById('hero-position').value || 'UTG';
            const primaryAction = document.getElementById('primary-action').value || 'open';
            const stackDepth = document.getElementById('stack-depth').value || '100bb';

            let ctx = '';

            if (primaryAction === 'open') {
                ctx = 'Open';
            } else if (primaryAction === 'defense') {
                const opener = document.getElementById('opener').value;
                if (opener) {
                    ctx = `Défense vs ${opener} open`;
                } else {
                    ctx = 'Défense';
                }
            } else if (primaryAction === 'squeeze') {
                const opener = document.getElementById('squeeze-opener').value;
                if (opener && selectedCallers.length > 0) {
                    ctx = `Squeeze vs ${opener} open + ${selectedCallers.join(' + ')} call`;
                } else if (opener) {
                    ctx = `Squeeze vs ${opener} open`;
                } else {
                    ctx = 'Squeeze';
                }
            } else if (primaryAction === 'vs_limpers') {
                const limpersCount = document.getElementById('limpers-count').value;
                if (limpersCount) {
                    ctx = `Vs ${limpersCount} limper(s)`;
                } else if (selectedLimpers.length > 0) {
                    ctx = `Vs ${selectedLimpers.join(' + ')} limp`;
                } else {
                    ctx = 'Vs limpers';
                }
            } else {
                ctx = primaryAction.charAt(0).toUpperCase() + primaryAction.slice(1);
            }

            const humanTitle = `${tableFormat} · ${heroPosition} · ${ctx} · ${stackDepth}`;

            const titleElement = document.getElementById('human-title');
            if (titleElement) {
                titleElement.textContent = humanTitle;
            }
        }

        // Charger les données du contexte
        async function loadContext() {
            const urlParams = new URLSearchParams(window.location.search);
            contextId = urlParams.get('id');

            if (!contextId) {
                showMessage('Erreur : ID de contexte manquant', 'error');
                return;
            }

            try {
                const response = await fetch(`/api/validation/context/${contextId}`);
                const data = await response.json();

                if (data.error) {
                    showMessage(data.error, 'error');
                    return;
                }

                contextData = data;

                (data.ranges || []).forEach(r => {
                    originalLabels[r.id] = r.label_canon;
                });

                displayContextInfo(data);
                displayWarnings(data.warnings || []);
                prefillForm(data);
                renderSubrangesTable(data.ranges || [], data.available_labels || {});
                checkFileExists(data.file_path);
            } catch (error) {
                showMessage('Erreur lors du chargement du contexte', 'error');
                console.error(error);
            }
        }

        async function checkFileExists(filePath) {
            try {
                const response = await fetch('/api/orphans/check');
                const data = await response.json();

                const isOrphan = data.orphans.some(o => o.context_id === contextId);

                if (isOrphan) {
                    const warningHtml = `
                        <div class="message error" style="display: flex; justify-content: space-between; align-items: center;">
                            <span>⚠️ <strong>Fichier JSON manquant</strong> - Le fichier source n'existe plus. Certaines fonctionnalités sont limitées.</span>
                            <div style="display: flex; gap: 10px;">
                                <button onclick="rebuildJSON()" class="btn btn-warning" style="padding: 8px 16px; font-size: 13px;">
                                    🔄 Reconstruire
                                </button>
                                <button onclick="window.location.href='/orphans'" class="btn btn-secondary" style="padding: 8px 16px; font-size: 13px;">
                                    Gérer les orphelins
                                </button>
                            </div>
                        </div>
                    `;
                    document.getElementById('message-container').innerHTML = warningHtml;
                }
            } catch (error) {
                console.error('Erreur check fichier:', error);
            }
        }

        async function rebuildJSON() {
            if (!confirm('Reconstruire le fichier JSON depuis la base de données ?')) return;

            try {
                const response = await fetch(`/api/orphans/rebuild/${contextId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' }
                });

                const result = await response.json();

                if (result.success) {
                    showMessage('✅ JSON reconstruit avec succès', 'success');
                    setTimeout(() => location.reload(), 1500);
                } else {
                    showMessage(`❌ ${result.message}`, 'error');
                }
            } catch (error) {
                showMessage('Erreur lors de la reconstruction', 'error');
            }
        }

        function displayWarnings(warnings) {
            const container = document.getElementById('warnings-container');
            if (!warnings || warnings.length === 0) {
                container.innerHTML = '';
                return;
            }

            const html = `
                <div class="warning-box">
                    <h3>⚠️ Incohérences détectées</h3>
                    <ul>
                        ${warnings.map(w => `<li>${w}</li>`).join('')}
                    </ul>
                </div>
            `;
            container.innerHTML = html;
        }

        function displayContextInfo(data) {
            document.getElementById('filename').textContent = data.filename || '-';
            document.getElementById('original-name').textContent = data.original_name || '-';
            document.getElementById('range-count').textContent = (data.ranges && data.ranges.length) || 0;

            const ht = document.getElementById('human-title');
            const sl = document.getElementById('slug');
            if (ht) ht.textContent = data.human_title || '—';
            if (sl) sl.textContent = data.slug || '—';

            renderSummaryChips(data.subranges_summary || {});
        }

        function renderSubrangesTable(ranges, availableLabels) {
            const tbody = document.getElementById('subranges-tbody');
            tbody.innerHTML = '';

            if (!ranges || ranges.length === 0) {
                tbody.innerHTML = '<tr><td colspan="5" style="text-align:center; padding:20px; color:#999;">Aucun sous-range à classifier</td></tr>';
                return;
            }

            ranges.forEach(range => {
                const tr = document.createElement('tr');
                tr.dataset.rangeId = range.id;

                const colorCell = document.createElement('td');
                colorCell.className = 'range-color-cell';
                colorCell.innerHTML = `<div class="range-color-indicator" style="background-color: ${range.color || '#e2e8f0'}"></div>`;

                const nameCell = document.createElement('td');
                nameCell.className = 'range-name-cell';
                nameCell.textContent = range.name || range.action || '(sans nom)';

                const handsCell = document.createElement('td');
                handsCell.className = 'range-hands-cell';
                handsCell.textContent = range.hand_count || 0;

                // 🎮 Nouvelle colonne : Séquence d'actions de quiz
                const quizActionCell = document.createElement('td');
                quizActionCell.className = 'quiz-action-cell';
                
                // Récupérer le primary_action du contexte
                const primaryAction = contextData?.primary_action || 'open';
                const rangeKey = range.range_key || (range.name === contextData?.ranges?.[0]?.name ? '1' : '2');
                
                // Générer la séquence d'actions
                const actionSequence = getQuizActionSequence(range.label_canon, primaryAction, rangeKey);
                
                // Créer le HTML de la séquence
                const sequenceDiv = document.createElement('div');
                sequenceDiv.className = 'quiz-action-sequence';
                
                let inGroup = false;
                let groupDiv = null;
                
                actionSequence.forEach((item, index) => {
                    if (item.grouped && !inGroup) {
                        // Début d'un groupe
                        inGroup = true;
                        groupDiv = document.createElement('div');
                        groupDiv.className = 'quiz-action-group';
                    }
                    
                    if (item.arrow) {
                        if (inGroup && groupDiv) {
                            sequenceDiv.appendChild(groupDiv);
                            inGroup = false;
                            groupDiv = null;
                        }
                        const arrow = document.createElement('span');
                        arrow.className = 'quiz-action-arrow';
                        arrow.textContent = '→';
                        sequenceDiv.appendChild(arrow);
                    } else if (item.slash) {
                        const slash = document.createElement('span');
                        slash.className = 'quiz-action-slash';
                        slash.textContent = '/';
                        if (inGroup && groupDiv) {
                            groupDiv.appendChild(slash);
                        } else {
                            sequenceDiv.appendChild(slash);
                        }
                    } else {
                        const badge = document.createElement('span');
                        badge.className = `quiz-action-badge quiz-action-${item.action}`;
                        badge.textContent = item.text;
                        
                        if (inGroup && groupDiv) {
                            groupDiv.appendChild(badge);
                        } else {
                            sequenceDiv.appendChild(badge);
                        }
                    }
                    
                    // Fin du groupe si c'est le dernier élément groupé
                    if (item.grouped && index === actionSequence.length - 1 && groupDiv) {
                        sequenceDiv.appendChild(groupDiv);
                        inGroup = false;
                        groupDiv = null;
                    }
                });
                
                // Cas où le groupe n'a pas été fermé
                if (inGroup && groupDiv) {
                    sequenceDiv.appendChild(groupDiv);
                }
                
                quizActionCell.appendChild(sequenceDiv);

                const labelCell = document.createElement('td');
                labelCell.className = 'range-label-cell';

                const select = document.createElement('select');
                select.className = 'range-label-select';
                select.dataset.rangeId = range.id;
                select.dataset.originalLabel = range.label_canon;

                Object.entries(availableLabels).forEach(([value, label]) => {
                    const option = document.createElement('option');
                    option.value = value;
                    option.textContent = label;
                    if (value === range.label_canon) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });

                select.addEventListener('change', (e) => {
                    const rangeId = parseInt(e.target.dataset.rangeId);
                    const originalLabel = e.target.dataset.originalLabel;
                    const newLabel = e.target.value;

                    if (newLabel !== originalLabel) {
                        modifiedLabels[rangeId] = newLabel;
                        e.target.classList.add('modified');
                    } else {
                        delete modifiedLabels[rangeId];
                        e.target.classList.remove('modified');
                    }

                    // 🎮 Mettre à jour la séquence d'actions
                    const newActionSequence = getQuizActionSequence(newLabel, primaryAction, rangeKey);
                    sequenceDiv.innerHTML = '';
                    
                    let inGroup = false;
                    let groupDiv = null;
                    
                    newActionSequence.forEach((item, index) => {
                        if (item.grouped && !inGroup) {
                            // Début d'un groupe
                            inGroup = true;
                            groupDiv = document.createElement('div');
                            groupDiv.className = 'quiz-action-group';
                        }
                        
                        if (item.arrow) {
                            if (inGroup && groupDiv) {
                                sequenceDiv.appendChild(groupDiv);
                                inGroup = false;
                                groupDiv = null;
                            }
                            const arrow = document.createElement('span');
                            arrow.className = 'quiz-action-arrow';
                            arrow.textContent = '→';
                            sequenceDiv.appendChild(arrow);
                        } else if (item.slash) {
                            const slash = document.createElement('span');
                            slash.className = 'quiz-action-slash';
                            slash.textContent = '/';
                            if (inGroup && groupDiv) {
                                groupDiv.appendChild(slash);
                            } else {
                                sequenceDiv.appendChild(slash);
                            }
                        } else {
                            const badge = document.createElement('span');
                            badge.className = `quiz-action-badge quiz-action-${item.action}`;
                            badge.textContent = item.text;
                            
                            if (inGroup && groupDiv) {
                                groupDiv.appendChild(badge);
                            } else {
                                sequenceDiv.appendChild(badge);
                            }
                        }
                        
                        // Fin du groupe si c'est le dernier élément groupé
                        if (item.grouped && index === newActionSequence.length - 1 && groupDiv) {
                            sequenceDiv.appendChild(groupDiv);
                            inGroup = false;
                            groupDiv = null;
                        }
                    });
                    
                    // Cas où le groupe n'a pas été fermé
                    if (inGroup && groupDiv) {
                        sequenceDiv.appendChild(groupDiv);
                    }

                    updateModifiedCount();
                });

                labelCell.appendChild(select);

                tr.appendChild(colorCell);
                tr.appendChild(nameCell);
                tr.appendChild(handsCell);
                tr.appendChild(quizActionCell); // 🎮 Colonne séquence
                tr.appendChild(labelCell);

                tbody.appendChild(tr);
            });
        }

        function updateModifiedCount() {
            const count = Object.keys(modifiedLabels).length;
            const indicator = document.getElementById('modified-count');

            if (count > 0) {
                indicator.innerHTML = `<span class="modified-indicator"></span> ${count} modifié${count > 1 ? 's' : ''}`;
            } else {
                indicator.innerHTML = '';
            }
        }

        function renderSummaryChips(summary) {
            const box = document.getElementById('subranges-summary');
            if (!box) return;
            box.innerHTML = '';
            const keys = Object.keys(summary || {});
            if (keys.length === 0) {
                box.innerHTML = '<span class="small-dim">Aucun sous-range détecté</span>';
                return;
            }

            const labels = contextData?.available_labels || {};
            keys.forEach(key => {
                const chip = document.createElement('span');
                chip.className = 'chip';
                const label = labels[key] || key;
                chip.textContent = `${label} · ${summary[key]}`;
                box.appendChild(chip);
            });
        }

        async function renameFile() {
            const slugEl = document.getElementById('slug');
            const slug = slugEl.textContent.trim();

            if (!slug || slug === '—') {
                showMessage('Slug non disponible', 'error');
                return;
            }

            const btn = document.getElementById('rename-btn');
            const originalText = btn.textContent;

            const newFilename = `${slug}.json`;
            if (!confirm(`Renommer le fichier en "${newFilename}" ?\n\nCette action est irréversible.`)) {
                return;
            }

            btn.disabled = true;
            btn.textContent = 'Renommage...';

            try {
                const response = await fetch(`/api/validation/rename-file/${contextId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ slug })
                });

                const result = await response.json();

                if (result.success) {
                    showMessage(`✅ ${result.message}`, 'success');

                    if (result.new_name) {
                        document.getElementById('filename').textContent = result.new_name;
                    }

                    btn.textContent = '✓ Fichier renommé';
                    btn.style.background = '#10b981';
                    btn.style.color = 'white';

                } else {
                    showMessage(`❌ ${result.message}`, 'error');
                    btn.disabled = false;
                    btn.textContent = originalText;
                }

            } catch (error) {
                console.error('Erreur renommage:', error);
                showMessage('Erreur lors du renommage', 'error');
                btn.disabled = false;
                btn.textContent = originalText;
            }
        }

        function prefillForm(data) {
            if (data.table_format) {
                selectOption('table-format', data.table_format);
                currentTableFormat = data.table_format;
            }
            if (data.hero_position) selectOption('hero-position', data.hero_position);

            if (data.primary_action) {
                document.querySelectorAll('.action-btn').forEach(btn => {
                    if (btn.dataset.value === data.primary_action) {
                        btn.classList.add('selected');
                        document.getElementById('primary-action').value = data.primary_action;
                        showDynamicSection(data.primary_action);
                    }
                });

                if (data.action_sequence) {
                    const seq = data.action_sequence;

                    if (data.primary_action === 'defense' && seq.opener) {
                        setTimeout(() => selectOption('opener', seq.opener), 100);
                    }

                    if (data.primary_action === 'squeeze') {
                        if (seq.opener) {
                            setTimeout(() => selectOption('squeeze-opener', seq.opener), 100);
                        }
                        if (seq.callers) {
                            selectedCallers = seq.callers;
                            setTimeout(() => renderSelectedCallers(), 100);
                        }
                        if (seq.callers_count) {
                            setTimeout(() => {
                                document.getElementById('callers-count').value = seq.callers_count;
                            }, 100);
                        }
                    }

                    if (data.primary_action === 'vs_limpers') {
                        if (seq.limpers) {
                            selectedLimpers = seq.limpers;
                            setTimeout(() => renderSelectedLimpers(), 100);
                        }
                        if (seq.limpers_count) {
                            setTimeout(() => {
                                document.getElementById('limpers-count').value = seq.limpers_count;
                            }, 100);
                        }
                    }
                }
            }

            if (data.stack_depth) document.getElementById('stack-depth').value = data.stack_depth;
            if (data.game_type) document.getElementById('game-type').value = data.game_type;
            if (data.variant) document.getElementById('variant').value = data.variant;
            if (data.sizing) document.getElementById('sizing').value = data.sizing;
            if (data.stakes) document.getElementById('stakes').value = data.stakes;

            // 🆕 Générer le slug initial après préchargement
            setTimeout(generateSlugLive, 200);
        }

        function selectOption(fieldId, value) {
            const buttons = document.querySelectorAll(`#${fieldId}-buttons .btn-option`);
            buttons.forEach(btn => {
                if (btn.dataset.value === value) {
                    btn.click();
                }
            });
        }

        function showDynamicSection(action) {
            document.querySelectorAll('.dynamic-section').forEach(section => {
                section.classList.remove('visible');
            });

            if (action === 'defense') {
                if (!validateDefensePositions()) return;
                document.getElementById('defense-details').classList.add('visible');
                updateDynamicPositionButtons('opener');
            } else if (action === 'squeeze') {
                if (!validateSqueezePositions()) return;
                document.getElementById('squeeze-details').classList.add('visible');
                updateDynamicPositionButtons('squeeze-opener');
                updateDynamicPositionButtons('callers');
            } else if (action === 'vs_limpers') {
                if (!validateLimpersPositions()) return;
                document.getElementById('limpers-details').classList.add('visible');
                updateDynamicPositionButtons('limpers');
            }
        }

        function updateDynamicPositionButtons(target) {
            const positions = POSITIONS_BY_FORMAT[currentTableFormat];
            const container = document.getElementById(`${target}-buttons`);

            if (!container) return;

            container.innerHTML = '';

            positions.forEach(pos => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'btn-option';
                btn.dataset.value = pos;
                btn.textContent = pos;

                if (target === 'callers') {
                    btn.addEventListener('click', () => addCaller(pos));
                } else if (target === 'limpers') {
                    btn.addEventListener('click', () => addLimper(pos));
                } else {
                    btn.addEventListener('click', (e) => {
                        container.querySelectorAll('.btn-option').forEach(b => b.classList.remove('selected'));
                        e.target.classList.add('selected');
                        const fieldId = target.replace('-buttons', '');
                        document.getElementById(fieldId).value = pos;

                        // 🆕 Si squeeze-opener, mettre à jour les contraintes des callers
                        if (target === 'squeeze-opener') {
                            const heroPosition = document.getElementById('hero-position').value;
                            const heroIdx = positions.indexOf(heroPosition);
                            updateCallersConstraints(positions, heroIdx);
                        }

                        generateSlugLive();
                    });
                }

                container.appendChild(btn);
            });

            // 🆕 Appliquer les contraintes après création des boutons
            const heroPosition = document.getElementById('hero-position').value;
            if (heroPosition) {
                const heroIdx = positions.indexOf(heroPosition);

                if (target === 'opener') {
                    updateDefensePositionConstraints(positions, heroIdx);
                } else if (target === 'squeeze-opener') {
                    updateSqueezePositionConstraints(positions, heroIdx);
                } else if (target === 'callers') {
                    updateCallersConstraints(positions, heroIdx);
                } else if (target === 'limpers') {
                    updateLimpersPositionConstraints(positions, heroIdx);
                }
            }
        }

        function addCaller(position) {
            if (!selectedCallers.includes(position)) {
                selectedCallers.push(position);
                renderSelectedCallers();
                document.getElementById('callers-count').value = '';
                generateSlugLive();
            }
        }

        function removeCaller(position) {
            selectedCallers = selectedCallers.filter(p => p !== position);
            renderSelectedCallers();
            generateSlugLive();
        }

        function renderSelectedCallers() {
            const container = document.getElementById('callers-container');
            container.innerHTML = '';

            if (selectedCallers.length === 0) {
                container.innerHTML = '<span class="small-dim">Aucun caller sélectionné</span>';
            } else {
                selectedCallers.forEach(pos => {
                    const tag = document.createElement('div');
                    tag.className = 'position-tag';
                    tag.innerHTML = `${pos} <button onclick="removeCaller('${pos}')">×</button>`;
                    container.appendChild(tag);
                });
            }

            document.getElementById('callers').value = selectedCallers.join(',');
        }

        function addLimper(position) {
            if (!selectedLimpers.includes(position)) {
                selectedLimpers.push(position);
                renderSelectedLimpers();
                document.getElementById('limpers-count').value = '';
                generateSlugLive();
            }
        }

        function removeLimper(position) {
            selectedLimpers = selectedLimpers.filter(p => p !== position);
            renderSelectedLimpers();
            generateSlugLive();
        }

        function renderSelectedLimpers() {
            const container = document.getElementById('limpers-container');
            container.innerHTML = '';

            if (selectedLimpers.length === 0) {
                container.innerHTML = '<span class="small-dim">Aucun limpeur sélectionné</span>';
            } else {
                selectedLimpers.forEach(pos => {
                    const tag = document.createElement('div');
                    tag.className = 'position-tag';
                    tag.innerHTML = `${pos} <button onclick="removeLimper('${pos}')">×</button>`;
                    container.appendChild(tag);
                });
            }

            document.getElementById('limpers').value = selectedLimpers.join(',');
        }

        // 🆕 ÉCOUTEURS D'ÉVÉNEMENTS POUR MISE À JOUR EN TEMPS RÉEL
        document.addEventListener('DOMContentLoaded', () => {
            const callersCountField = document.getElementById('callers-count');
            const limpersCountField = document.getElementById('limpers-count');

            if (callersCountField) {
                callersCountField.addEventListener('input', () => {
                    if (callersCountField.value) {
                        selectedCallers = [];
                        renderSelectedCallers();
                    }
                    generateSlugLive();
                });
            }

            if (limpersCountField) {
                limpersCountField.addEventListener('input', () => {
                    if (limpersCountField.value) {
                        selectedLimpers = [];
                        renderSelectedLimpers();
                    }
                    generateSlugLive();
                });
            }

            document.getElementById('stack-depth').addEventListener('change', generateSlugLive);
        });

        document.getElementById('table-format-buttons').addEventListener('click', (e) => {
            if (e.target.classList.contains('btn-option')) {
                document.querySelectorAll('#table-format-buttons .btn-option').forEach(btn => {
                    btn.classList.remove('selected');
                });
                e.target.classList.add('selected');
                const format = e.target.dataset.value;
                document.getElementById('table-format').value = format;
                currentTableFormat = format;
                updatePositionButtons(format);

                const primaryAction = document.getElementById('primary-action').value;
                if (primaryAction) {
                    showDynamicSection(primaryAction);
                }

                generateSlugLive();

                // 🆕 Revalider après changement de format
                const heroPosition = document.getElementById('hero-position').value;
                if (heroPosition && primaryAction) {
                    if (primaryAction === 'defense') validateDefensePositions();
                    else if (primaryAction === 'squeeze') validateSqueezePositions();
                    else if (primaryAction === 'vs_limpers') validateLimpersPositions();
                }
            }
        });

        function updatePositionButtons(format) {
            const positions = POSITIONS_BY_FORMAT[format];

            const heroContainer = document.getElementById('hero-position-buttons');
            heroContainer.innerHTML = '';
            positions.forEach(pos => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'btn-option hero-btn';
                btn.dataset.value = pos;
                btn.textContent = pos;
                heroContainer.appendChild(btn);
            });

            document.getElementById('hero-position').value = '';
            document.querySelectorAll('.hero-btn').forEach(btn => btn.classList.remove('selected'));
        }

        document.querySelectorAll('.action-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                document.querySelectorAll('.action-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                const action = btn.dataset.value;
                document.getElementById('primary-action').value = action;

                // 🆕 Masquer tous les warnings d'abord
                document.getElementById('defense-warning').style.display = 'none';
                document.getElementById('squeeze-warning').style.display = 'none';
                document.getElementById('limpers-warning').style.display = 'none';

                showDynamicSection(action);
                generateSlugLive();
            });
        });

        document.getElementById('hero-position-buttons').addEventListener('click', (e) => {
            if (e.target.classList.contains('hero-btn')) {
                document.querySelectorAll('.hero-btn').forEach(b => b.classList.remove('selected'));
                e.target.classList.add('selected');
                document.getElementById('hero-position').value = e.target.dataset.value;

                // 🆕 Valider immédiatement (AVANT de regénérer la section)
                const primaryAction = document.getElementById('primary-action').value;
                if (primaryAction === 'defense') {
                    validateDefensePositions();
                } else if (primaryAction === 'squeeze') {
                    validateSqueezePositions();
                } else if (primaryAction === 'vs_limpers') {
                    validateLimpersPositions();
                }

                generateSlugLive();
            }
        });

        // Soumettre le formulaire
        document.getElementById('validation-form').addEventListener('submit', async (e) => {
            e.preventDefault();

            const allRangeLabels = {};
            document.querySelectorAll('.range-label-select').forEach(select => {
                const rangeId = parseInt(select.dataset.rangeId);
                const label = select.value;
                allRangeLabels[rangeId] = label;
            });

            const primaryAction = document.getElementById('primary-action').value;

            const formData = {
                table_format: document.getElementById('table-format').value,
                hero_position: document.getElementById('hero-position').value,
                primary_action: primaryAction,
                stack_depth: document.getElementById('stack-depth').value,
                game_type: document.getElementById('game-type').value,
                variant: document.getElementById('variant').value,
                sizing: document.getElementById('sizing').value,
                stakes: document.getElementById('stakes').value,
                update_json: document.getElementById('update-json').checked,
                range_labels: Object.keys(allRangeLabels).length > 0 ? allRangeLabels : null
            };

            if (primaryAction === 'defense') {
                formData.opener = document.getElementById('opener').value;
            } else if (primaryAction === 'squeeze') {
                formData.opener = document.getElementById('squeeze-opener').value;
                formData.callers = document.getElementById('callers').value;
                formData.callers_count = document.getElementById('callers-count').value;
            } else if (primaryAction === 'vs_limpers') {
                formData.limpers = document.getElementById('limpers').value;
                formData.limpers_count = document.getElementById('limpers-count').value;
            }

            if (!formData.table_format || !formData.hero_position || !formData.primary_action) {
                showMessage('Veuillez remplir tous les champs obligatoires', 'error');
                return;
            }

            try {
                const response = await fetch(`/api/validation/validate/${contextId}`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(formData)
                });

                const result = await response.json();

                if (result.success) {
                    showMessage(result.message, 'success');
                    setTimeout(() => { window.location.href = '/?validated=true'; }, 1500);
                } else {
                    showMessage(result.message, 'error');
                }
            } catch (error) {
                showMessage('Erreur lors de la validation', 'error');
                console.error(error);
            }
        });

        document.getElementById('btn-ignore').addEventListener('click', async () => {
            if (!confirm('Êtes-vous sûr de vouloir marquer ce contexte comme non exploitable ?')) return;

            try {
                const response = await fetch(`/api/validation/ignore/${contextId}`, { method: 'POST' });
                const result = await response.json();

                if (result.success) {
                    showMessage('Contexte marqué comme non exploitable', 'success');
                    setTimeout(() => { window.location.href = '/'; }, 1500);
                } else {
                    showMessage(result.message, 'error');
                }
            } catch (error) {
                showMessage('Erreur lors de l\'opération', 'error');
                console.error(error);
            }
        });

        function showMessage(text, type) {
            const container = document.getElementById('message-container');
            container.innerHTML = `<div class="message ${type}">${text}</div>`;
            if (type === 'success') setTimeout(() => { container.innerHTML = ''; }, 3000);
        }

        loadContext();
    </script>
</body>
</html>